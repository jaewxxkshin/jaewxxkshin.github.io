---
layout: single
title: "OpenCV 프로그래밍 - Chapter 03 OpenCV 기본연산(1)"
categories: OpenCV
tags: [OpenCV, Python]
toc: true
toc_sticky: true
---

# 이 포스팅은 'python으로 배우는 OpenCV 프로그래밍' 교재를 참고하여 작성하였습니다.
## 01 영상 속성과 화소 접근  
OpenCV는 영상을 numpy.ndarray을 이용하여 표현한다.  
영상의 중요 속성(shape, dtype)을 확인하고, numpy의 astype(), reshape로 속성을 변경하고, 영상 화소를 y(행), x(열) 순으로 인덱스를 지정 접근하여 밝기 또는 컬러 값을 접근한다.  



| 구분               | numpy 자료형  | OpenCV 자료형, 1-채널 |
|------------------|------------|------------------|
| 8비트 unsigned 정수  | np.uint8   | cv2.CV_8U(1)     | 
| 8비트 signed 정수    | np.int8    | cv2.CV_8S(1)     | 
| 16비트 unsigned 정수 | np.uint16  | cv2.CV_16U(1)    | 
| 16비트 signed 정수   | np.int16   | cv2.CV_16S(1)    | 
| 32비트 signed 정수   | np.int32   | cv2.CV_32S(1)    | 
| 32비트 실수          | np.float32 | cv2.CV_32F(1)    | 
| 64비트 실수          | np.float64 | cv2.CV_64F(1)    | 


OpenCV 함수에서 결과 영상의 화소 자료형을 요구하는 경우는 화소비트, 자료형, 채널수를 명시한 OpenCV 자료형 상수를 사용한다.  
1-채널을 자료형으로 할 경우 1은 생략가능하다. 
### 영상 속성 1 : 모양, 자료형
~~~python
import cv2
import numpy as np

img = cv2.imread('./data/lena.jpg') # cv2.IMREAD_COLOR
##img = cv2.imread('./data/lena.jpg', cv2.IMREAD_GRAYSCALE)

print('img.ndim=', img.ndim)
print('img.shape=', img.shape)
print('img.dtype=', img.dtype)

## np.bool, np.uint16, np.uint32, np.float32, np.float64, np.complex64
img=img.astype(np.int32)
print('img.dtype=',img.dtype)

img=np.uint8(img)
print('img.dtype=',img.dtype)
~~~
위 코드를 주석을 수정하여 두번에 걸쳐 실행시키면 다음과 같은 결과가 출력된다.  
~~~python
img.ndim= 3
img.shape= (512, 512, 3)
img.dtype= uint8
img.dtype= int32
img.dtype= uint8
~~~
첫번째 출력 결과는 `cv2.IMREAD_COLOR`메서드를 사용해서 이미지를 읽었으므로 3차원 배열이며 img.shape[0]은 영상의 세로 화소 크기, img.shape[1]은 영상의 가로 화소 크기, img.shape[2]는 영상의 채널 개수이다.  
또한 `img.astype()`메서드를 사용해서 자료형을 변환할 수 있고, 그냥 변수자체로도 변환 가능하다.  

~~~python
img.ndim= 2
img.shape= (512, 512)
img.dtype= uint8
img.dtype= int32
img.dtype= uint8
~~~
두번째 출력 결과는 `cv2.IMREAD_GRAYSCALE`메서드를 사용해서 이미지를 읽었으므로 채널이 1차원이 되어서, 2차원 배열이며 영상의 세로, 가로 화소 크기를 의미한다.  
영상처리 계산을 위해서 다양한 자료형으로 변경할 필요가 있는데, 이때 계산을 마친 후 윈도우에 영상을 표시하기 위한 `cv2.imshow()`메서드는 uint8 자료형의 영상만을 화면에 표시하므로 윈도우에 영상을 표시하려면 반드시 코드 마지막에 영상의 자료형을 uint8로 변환해줘야 한다.  
### 영상 속성 2 : 모양 변경하기
~~~python
import cv2
##import numpy as np

img = cv2.imread('./data/lena.jpg', cv2.IMREAD_GRAYSCALE)
print('img.shape=', img.shape)

#img = img.reshape(img.shape[0]*img.shape[1])
img = img.flatten()
print('img.shape=', img.shape)

img = img.reshape(-1, 512, 512)
print('img.shape=', img.shape)
print('img[0].shape=',img[0].shape)

cv2.imshow('img', img[0])
cv2.waitKey()
cv2.destroyAllWindows()
~~~
위 코드를 실행한 결과는 다음과 같다.
~~~python
img.shape= (512, 512)
img.shape= (262144,)
img.shape= (1, 512, 512)
img[0].shape= (512, 512)
~~~
![image](https://user-images.githubusercontent.com/98035435/152806022-869e1b79-839a-4592-ac79-ba36cc39a6d1.png){:.align-center}
첫번째 출력문에서는 `cv2.IMREAD_GRAYSCALE`메서드를 사용한 이미지의 shape인 (512, 512)를 출력한다.  
두번째 출력문에서는 `img.flatten()`메서드에 의해 2차원 배열에서 1차원 배열로 변환되어 512 * 512인 (262144, )를 출력한다.  
세번째 출력문에서는 `img.reshape(-1, 512, 512)`에 의해 1차원 배열을 다시 3차원 배열로 확장한다.
reshape 메써드의 첫번째 파라미터는 채널의 새로운 개수이고 두번째 파라미터는 행(rows)의 새로운 개수이고 세번째 파라미터는 열(column)의 새로운 개수이다.  
첫번째 파라미터인 채널의 새로운 개수를 -1로 설정하면 채널의 개수를 자동으로 계산한다.  
위 코드에서의 img는 화소 크기가 512*512이므로 (1, 512, 512)로 확장된다.(계산적으로 512 * 512 = 262144이므로 1이 될 수 밖에 없다) 
따라서 네번째 출력문에서는 img[0].shape= (512, 512)임을 확인할 수 있고, `cv2.imshow('img', img[0])`메서드를 통해 그레이스케일 영상을 윈도우에 표시할 수 있다.  
또한 윈도우에 이미지가 정상적으로 표시되므로, `img.reshape()`메서드는 실제 데이터(각 픽셀의 값)를 변경하지는 않고, 모양을 변경한다는 것을 알 수 있다.  
위 코드를 컬러로 읽어와서 실행시켰을때는 윈도우에 이미지가 정상적으로 출력되지 않는데 추후에 이를 디버깅 해봐야겠다...!
### 영상속성 2 : 모양 변경하기(custom)
~~~python
import cv2
##import numpy as np

img = cv2.imread('./data/lena.jpg')
print('img.shape=', img.shape)

#img = img.reshape(img.shape[0]*img.shape[1])
img = img.flatten()
print('img.shape=', img.shape)

img = img.reshape(-1, 512, 512)
print('img.shape=', img.shape)
print('img[0].shape=',img[0].shape)

cv2.imshow('img', img[0])
cv2.waitKey()
cv2.destroyAllWindows()
~~~
실행 결과는 다음과 같다.  
~~~python
img.shape= (512, 512, 3)
img.shape= (786432,)
img.shape= (3, 512, 512)
img[0].shape= (512, 512)
~~~
![image](https://user-images.githubusercontent.com/98035435/152805443-fd78bf83-8d97-4b95-b451-577629bb131b.png){:.align-center}  
윈도우에 다음과 같이 표시되는 이유가 뭘까,,,,,???

### 화소 접근 1 : 그레이스케일 영상
~~~python
import cv2
##import numpy as np

img = cv2.imread('./data/lena.jpg', cv2.IMREAD_GRAYSCALE)
img[100, 200] = 0  # 화소값(밝기,그레이스케일) 변경
print(img[100:110, 200:210]) # ROI 접근

##for y in range(100, 400):
##    for x in range(200, 300):
##        img[y, x] = 0

img[100:400, 200:300] = 0    # ROI 접근

cv2.imshow('img', img)
cv2.waitKey()
cv2.destroyAllWindows()
~~~
위 코드의 실행 결과는 다음과 같다.
~~~python
befor ROI:
 [[146 143 145 132 147 144 142 139 132 138]
 [138 138 143 151 137 144 139 139 138 138]
 [132 139 153 140 133 136 143 138 137 128]
 [137 146 138 125 132 145 139 142 130 128]
 [149 139 130 137 140 145 136 133 132 141]
 [141 139 134 149 149 137 132 127 140 140]
 [142 148 139 142 144 138 146 135 131 130]
 [151 146 136 131 142 144 149 135 126 132]
 [147 131 135 138 147 139 128 125 134 138]
 [135 132 149 142 134 128 122 135 138 129]]
after ROI:
 [[0 0 0 0 0 0 0 0 0 0]
 [0 0 0 0 0 0 0 0 0 0]
 [0 0 0 0 0 0 0 0 0 0]
 [0 0 0 0 0 0 0 0 0 0]
 [0 0 0 0 0 0 0 0 0 0]
 [0 0 0 0 0 0 0 0 0 0]
 [0 0 0 0 0 0 0 0 0 0]
 [0 0 0 0 0 0 0 0 0 0]
 [0 0 0 0 0 0 0 0 0 0]
 [0 0 0 0 0 0 0 0 0 0]]
 ~~~
img[100:110, 200:210] = 0 문장을 실행하기 전에는 각 픽셀마다 그레이스케일의 밝기값을 갖고 있었지만, 위 문장이 실행된 후에는 각 픽셀의 값이 0으로 변환된다.  
위 문법은 슬라이싱 기본 문법이다.  
주석처리된 for문도 img[100:110, 200:210] = 0와 같은 결과를 나타낼 것이다.  
또한 img[y ,x]를 나타내므로 윈도우에 표시되는 결과는 다음과 같다.  
![image](https://user-images.githubusercontent.com/98035435/152824079-032dde5d-7d47-4100-b4a2-38d4f4573da8.png){:.align-center}  
자세히 보면 레나의 모자쪽에 밝기가 0(검정색)인 (10 * 10)크기의 여백이 생겼음을 알 수 있다.

### 화소 접근 2 : 컬러영상(BGR)
~~~python
import cv2
##import numpy as np

img = cv2.imread('./data/lena.jpg') # cv2.IMREAD_COLOR

##for y in range(100, 400):
##    for x in range(200, 300):
##        img[y, x] = [255, 0, 0]    # 파랑색(blue)으로 변경

img[100:400, 200:300] = [255, 0, 0]  # ROI 접근
    
cv2.imshow('img', img)
cv2.waitKey()
cv2.destroyAllWindows()
~~~
BGR컬러 영상도 어려울 것 없다.  
이미지를 디폴트로 BGR컬러로 읽어온 후 마찬가지 방법으로 일정 범위의 색을 지정할 수 있는데, 그레이스케일과 달리 채널이 3개임을 유의해야 한다.  
윈도우에 표시되는 결과는 다음과 같다.  
![image](https://user-images.githubusercontent.com/98035435/152825058-a39b928b-c4b4-4d0c-9317-4d164694b131.png){:.align-center}  

### 화소 접근 3 : 컬러영상(채널 접근)
~~~python
import cv2
##import numpy as np

img = cv2.imread('./data/lena.jpg') # cv2.IMREAD_COLOR

##for y in range(100, 400):
##    for x in range(200, 300):
##        img[y, x, 0] = 255      # B-채널을 255로 변경
        
img[100:400, 200:300, 0] = 255  # B-채널을 255로 변경
img[100:400, 300:400, 1] = 255  # G-채널을 255로 변경
img[100:400, 400:500, 2] = 255  # R-채널을 255로 변경

cv2.imshow('img', img)
cv2.waitKey()
cv2.destroyAllWindows()
~~~
앞선 코드에선 일정 영역의 픽셀을 3채널의 값을 모두 입력해주어서 완전한 파란색 영역을 만들었지만. 위 코드는 각 영역의 B,G,R값을 각각 조절하여 본래 픽셀의 다른 채널 값을 유지하며 B,G,R값만 최대치로 조절한다.  
윈도우에 표시되는 결과는 다음과 같다.  
![image](https://user-images.githubusercontent.com/98035435/152826738-6e51dcc2-132a-41f3-9ef2-a9b0a27b076c.png){:.align-center}  
즉, 0 - Blue, 1 - Green, 2- Red를 의미하며 기초 중에 기초 내용이므로 반드시 숙지하자.  

## 02 관심 영역과 ROI

## 03 영상 복사

## 04 영상 채널 분리와 합성